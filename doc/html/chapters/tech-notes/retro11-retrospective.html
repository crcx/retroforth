<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>doc/book/tech-notes/retro11-retrospective</title>
<style type="text/css">

    * { color: #000; background: #fff; max-width: 700px; }
    tt, pre { background: #dedede; color: #111; font-family: monospace;
             white-space: pre; display: block; width: 100%; }
    .indentedcode { margin-left: 2em; margin-right: 2em; }
    .codeblock {
      background: #dedede; color: #111; font-family: monospace;
      box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
      padding: 7px;
      display: block;
    }

    .indentedlist { margin-left: 2em; color: #000; }

    span { white-space: pre; }
    .text  { color: #000; white-space: pre; background: #dedede; }
    .colon { color: #000; background: #dedede; }
    .note  { color: #000; background: #dedede; }
    .str   { color: #000; text-decoration: underline; background: #dedede; }
    .num   { color: #000; background: #dedede; font-weight: bold; font-style: italic; }
    .fnum  { color: #000; font-weight: bold; background: #dedede; }
    .ptr   { color: #000; font-weight: bold; background: #dedede; }
    .fetch { color: #000; font-style: italic; background: #dedede; }
    .store { color: #000; font-style: italic; background: #dedede; }
    .char  { color: #000; background: #dedede; }
    .inst  { color: #000; background: #dedede; }
    .defer { color: #000; background: #dedede; }
    .imm   { color: #000; font-weight: bold; background: #dedede; }
    .prim  { color: #000; font-weight: bolder; background: #dedede; }

    .tt    { white-space: pre; font-family: monospace; background: #dedede; }

    .h1, .h2, .h3, .h4 { white-space: normal; }
    .h1 { font-size: 125%; }
    .h2 { font-size: 120%; }
    .h3 { font-size: 115%; }
    .h4 { font-size: 110%; }
    .hr { display: block; height: 2px; background: #000000; }
</style>
</head><body>
<p><span class="h2">Retro 11 (2011 - 2019): A Look Back</span>
<br/><br/>
So it's now been about five years since the last release of Retro
11. While I still see some people obtaining and using it, I've
moved on to the twelth generation of Retro. It's time for me to
finally retire Retro 11.
<br/><br/>
As I prepare to do so, I thought I'd take a brief look back.
<br/><br/>
Retro 11 began life in 2011. It grew out of Retro 10, which was
the first version of Retro to not be written in x86 assembly
language. For R10 and R11, I wrote a portable virtual machine
(with numerous implementations) and the Forth dialect was kept
in an image file which ran on the VM.
<br/><br/>
Retro 10 worked, but was always a bit too sloppy and changed
drastically between releases. The major goal of Retro 11 was to
provide a stable base for a five year period. In retrospect,
this was mostly achieved. Code from earlier releases normally
needed only minor adjustments to run on later releases, though
newer releases added significantly to the language.
<br/><br/>
There were seven releases.
<br/><br/>
&bull; Release 11.0: 2011, July<br/>
&bull; Release 11.1: 2011, November<br/>
&bull; Release 11.2: 2012, January<br/>
&bull; Release 11.3: 2012, March<br/>
&bull; Release 11.4: 2012, July<br/>
&bull; Release 11.5: 2013, March<br/>
&bull; Release 11.6: 2014, August<br/>
<br/><br/>
Development was fast until 11.4. This was the point at which I
had to slow down due to RSI problems. It was also the point
which I started experiencing some problems with the metacompiler
(as discussed previously).
<br/><br/>
Retro 11 was flexible. All colon definitions were setup as hooks,
allowing new functionality to be layered in easily. This allowed
the later releases to add things like vocabularies, search order,
tab completion, and keyboard remapping. This all came at a cost
though: later things could use the hooks to alter behavior of
existing words, so it was necessary to use a lot of caution to
ensure that the layers didn't break the earlier code.
<br/><br/>
The biggest issue was the I/O model. Retro 11 and the Ngaro VM
assumed the existence of a console environment. All input was
required to be input at the keyboard, and all output was to be
shown on screen. This caused some problems. Including code from
a file required some tricks, temporarily rewriting the keyboard
input function to read from the file. It also became a major
issue when I wrote the iOS version. The need to simulate the
keyboard and console complicated everything and I had to spend
a considerable amount of effort to deal with battery performance
resulting from the I/O polling and wait states.
<br/><br/>
But on the whole it worked well. I used Retro 11.6 until I started
work on Retro 12 in late 2016, and continued running some tools
written in R11 until the first quarter of last year.
<br/><br/>
The final image file was 23,137 cells (92,548 bytes). This was
bloated by keeping some documentation (stack comments and short
descriptions) in the image, which started in 11.4. This contained
269 words.
<br/><br/>
I used Retro 11 for a wide variety of tasks. A small selection of
things that were written includes:
<br/><br/>
&bull; a pastebin<br/>
&bull; front end to ii (irc client)<br/>
&bull; small explorations of interactive fiction<br/>
&bull; irc log viewer<br/>
&bull; tool to create html from templates<br/>
&bull; tool to automate creation of an SVCD from a set of photos<br/>
&bull; tools to generate reports from data sets for my employer<br/>
<br/><br/>
In the end, I'm happy with how Retro 11 turned out. I made some
mistakes in embracing too much complexity, but despite this it
was a successful system for many years.
</p>
</body></html>
